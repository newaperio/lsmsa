<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>RKObjectLoaderDelegate Protocol Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.0.5 (build 789)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">RestKit </a></h1>
				<a id="developerHome" href="../index.html">RestKit</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">RKObjectLoaderDelegate Protocol Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/objectLoader:didFailWithError:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:didFailWithError:</option>
	
	<option value="//api/name/objectLoader:didLoadObject:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:didLoadObject:</option>
	
	<option value="//api/name/objectLoader:didLoadObjectDictionary:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:didLoadObjectDictionary:</option>
	
	<option value="//api/name/objectLoader:didLoadObjects:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:didLoadObjects:</option>
	
	<option value="//api/name/objectLoader:didSerializeSourceObject:toSerialization:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:didSerializeSourceObject:toSerialization:</option>
	
	<option value="//api/name/objectLoader:willMapData:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoader:willMapData:</option>
	
	<option value="//api/name/objectLoaderDidFinishLoading:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoaderDidFinishLoading:</option>
	
	<option value="//api/name/objectLoaderDidLoadUnexpectedResponse:">&nbsp;&nbsp;&nbsp;&nbsp;- objectLoaderDidLoadUnexpectedResponse:</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>









<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:didFailWithError:">objectLoader:didFailWithError:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:didLoadObject:">objectLoader:didLoadObject:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:didLoadObjectDictionary:">objectLoader:didLoadObjectDictionary:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:didLoadObjects:">objectLoader:didLoadObjects:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:didSerializeSourceObject:toSerialization:">objectLoader:didSerializeSourceObject:toSerialization:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoader:willMapData:">objectLoader:willMapData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoaderDidFinishLoading:">objectLoaderDidFinishLoading:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/objectLoaderDidLoadUnexpectedResponse:">objectLoaderDidLoadUnexpectedResponse:</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="RKObjectLoaderDelegate Protocol Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">RKObjectLoaderDelegate Protocol Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Conforms to</td>
	<td class="specification-value"><a href="../Protocols/RKRequestDelegate.html">RKRequestDelegate</a></td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">RKObjectLoader.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>The delegate of an <a href="../Classes/RKObjectLoader.html">RKObjectLoader</a> object must adopt the <a href="RKObjectLoaderDelegate.html">RKObjectLoaderDelegate</a> protocol. Optional
methods of the protocol allow the delegate to handle asynchronous object mapping operations performed
by the object loader. Also note that the <a href="RKObjectLoaderDelegate.html">RKObjectLoaderDelegate</a> protocol incorporates the
<a href="../Protocols/RKRequestDelegate.html">RKRequestDelegate</a> protocol and the delegate may provide implementations of methods from <a href="../Protocols/RKRequestDelegate.html">RKRequestDelegate</a>
as well.</p>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:didFailWithError:">&ndash;&nbsp;objectLoader:didFailWithError:</a></code>
		<span class="tooltip"><p>Sent when an object loaded failed to load the collection due to an error</p></span>
	</span>
	
	<span class="task-item-suffix">required method</span>
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:didLoadObjects:">&ndash;&nbsp;objectLoader:didLoadObjects:</a></code>
		<span class="tooltip"><p>When implemented, sent to the delegate when the object laoder has completed successfully
and loaded a collection of objects. All objects mapped from the remote payload will be returned
as a single array.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:didLoadObject:">&ndash;&nbsp;objectLoader:didLoadObject:</a></code>
		<span class="tooltip"><p>When implemented, sent to the delegate when the object loader has completed succesfully.
If the load resulted in a collection of objects being mapped, only the first object
in the collection will be sent with this delegate method. This method simplifies things
when you know you are working with a single object reference.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:didLoadObjectDictionary:">&ndash;&nbsp;objectLoader:didLoadObjectDictionary:</a></code>
		<span class="tooltip"><p>When implemented, sent to the delegate when an object loader has completed successfully. The
dictionary will be expressed as pairs of keyPaths and objects mapped from the payload. This
method is useful when you have multiple root objects and want to differentiate them by keyPath.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoaderDidFinishLoading:">&ndash;&nbsp;objectLoaderDidFinishLoading:</a></code>
		<span class="tooltip"><p>Invoked when the object loader has finished loading</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:didSerializeSourceObject:toSerialization:">&ndash;&nbsp;objectLoader:didSerializeSourceObject:toSerialization:</a></code>
		<span class="tooltip"><p>Informs the delegate that the object loader has serialized the source object into a serializable representation
for sending to the remote system. The serialization can be modified to allow customization of the request payload independent of mapping.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoaderDidLoadUnexpectedResponse:">&ndash;&nbsp;objectLoaderDidLoadUnexpectedResponse:</a></code>
		<span class="tooltip"><p>Sent when an object loader encounters a response status code or MIME Type that RestKit does not know how to handle.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/objectLoader:willMapData:">&ndash;&nbsp;objectLoader:willMapData:</a></code>
		<span class="tooltip"><p>Invoked just after parsing has completed, but before object mapping begins. This can be helpful
to extract data from the parsed payload that is not object mapped, but is interesting for one
reason or another. The mappableData will be made mutable via mutableCopy before the delegate
method is invoked.</p></span>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:didFailWithError:" title="objectLoader:didFailWithError:"></a>
	<h3 class="subsubtitle method-title">objectLoader:didFailWithError:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Sent when an object loaded failed to load the collection due to an error</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>objectLoader</em> didFailWithError:(NSError *)<em>error</em></code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:didLoadObject:" title="objectLoader:didLoadObject:"></a>
	<h3 class="subsubtitle method-title">objectLoader:didLoadObject:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>When implemented, sent to the delegate when the object loader has completed succesfully.
If the load resulted in a collection of objects being mapped, only the first object
in the collection will be sent with this delegate method. This method simplifies things
when you know you are working with a single object reference.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>objectLoader</em> didLoadObject:(id)<em>object</em></code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:didLoadObjectDictionary:" title="objectLoader:didLoadObjectDictionary:"></a>
	<h3 class="subsubtitle method-title">objectLoader:didLoadObjectDictionary:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>When implemented, sent to the delegate when an object loader has completed successfully. The
dictionary will be expressed as pairs of keyPaths and objects mapped from the payload. This
method is useful when you have multiple root objects and want to differentiate them by keyPath.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>objectLoader</em> didLoadObjectDictionary:(NSDictionary *)<em>dictionary</em></code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:didLoadObjects:" title="objectLoader:didLoadObjects:"></a>
	<h3 class="subsubtitle method-title">objectLoader:didLoadObjects:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>When implemented, sent to the delegate when the object laoder has completed successfully
and loaded a collection of objects. All objects mapped from the remote payload will be returned
as a single array.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>objectLoader</em> didLoadObjects:(NSArray *)<em>objects</em></code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:didSerializeSourceObject:toSerialization:" title="objectLoader:didSerializeSourceObject:toSerialization:"></a>
	<h3 class="subsubtitle method-title">objectLoader:didSerializeSourceObject:toSerialization:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Informs the delegate that the object loader has serialized the source object into a serializable representation
for sending to the remote system. The serialization can be modified to allow customization of the request payload independent of mapping.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>objectLoader</em> didSerializeSourceObject:(id)<em>sourceObject</em> toSerialization:(inout id&lt;RKRequestSerializable&gt; *)<em>serialization</em></code></div>
	
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>objectLoader</em></dt>
			<dd><p>The object loader performing the serialization.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>sourceObject</em></dt>
			<dd><p>The object that was serialized.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>serialization</em></dt>
			<dd><p>The serialization of sourceObject to be sent to the remote backend for processing.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoader:willMapData:" title="objectLoader:willMapData:"></a>
	<h3 class="subsubtitle method-title">objectLoader:willMapData:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Invoked just after parsing has completed, but before object mapping begins. This can be helpful
to extract data from the parsed payload that is not object mapped, but is interesting for one
reason or another. The mappableData will be made mutable via mutableCopy before the delegate
method is invoked.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoader:(RKObjectLoader *)<em>loader</em> willMapData:(inout id *)<em>mappableData</em></code></div>
	
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Note that the mappable data is a pointer to a pointer to allow you to replace the mappable data
with a new object to be mapped. You must dereference it to access the value.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoaderDidFinishLoading:" title="objectLoaderDidFinishLoading:"></a>
	<h3 class="subsubtitle method-title">objectLoaderDidFinishLoading:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Invoked when the object loader has finished loading</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoaderDidFinishLoading:(RKObjectLoader *)<em>objectLoader</em></code></div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/objectLoaderDidLoadUnexpectedResponse:" title="objectLoaderDidLoadUnexpectedResponse:"></a>
	<h3 class="subsubtitle method-title">objectLoaderDidLoadUnexpectedResponse:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Sent when an object loader encounters a response status code or MIME Type that RestKit does not know how to handle.</p>
	</div>		
	
	
	<div class="method-subsection method-declaration"><code>- (void)objectLoaderDidLoadUnexpectedResponse:(RKObjectLoader *)<em>objectLoader</em></code></div>
	
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Response codes in the 2xx, 4xx, and 5xx range are all handled as you would expect. 2xx (successful) response codes
are considered a successful content load and object mapping will be attempted. 4xx and 5xx are interpretted as
errors and RestKit will attempt to object map an error out of the payload (provided the MIME Type is mappable)
and will invoke objectLoader:didFailWithError: after constructing an NSError. Any other status code is considered
unexpected and will cause objectLoaderDidLoadUnexpectedResponse: to be invoked provided that you have provided
an implementation in your delegate class.</p>

<p>RestKit will also invoke objectLoaderDidLoadUnexpectedResponse: in the event that content is loaded, but there
is not a parser registered to handle the MIME Type of the payload. This often happens when the remote backend
system RestKit is talking to generates an HTML error page on failure. If your remote system returns content
in a MIME Type other than application/json or application/xml, you must register the MIME Type and an appropriate
parser with the [RKParserRegistry sharedParser] instance.</p>

<p>Also note that in the event RestKit encounters an unexpected status code or MIME Type response an error will be
constructed and sent to the delegate via objectLoader:didFailsWithError: unless your delegate provides an
implementation of objectLoaderDidLoadUnexpectedResponse:. It is recommended that you provide an implementation
and attempt to handle common unexpected MIME types (particularly text/html and text/plain).</p>

<p>@optional</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">RKObjectLoader.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2012 RestKit. All rights reserved. (Last updated: 2012-05-23)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.0.5 (build 789)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;

			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}

		</script>
	</body>
</html>